name: Review Specs and Implementation
on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  assist:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Cursor CLI
        run: |
          curl https://cursor.com/install -fsS | bash
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH

      - name: Configure git
        run: |
          git config user.name "Cursor Agent"
          git config user.email "cursoragent@cursor.com"

      - name: Review specs and implementation
        timeout-minutes: 5
        env:
          MODEL: "auto"
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH_PREFIX: spec-review
        run: |
          echo "Reviewing specs and implementation for PR ${{ github.event.pull_request.number }}"
          echo "You are operating in a GitHub Actions runner with full access to analyze and comment on pull requests.

          # Context:
          - Repository: ${{ github.repository }}
          - PR Number: ${{ github.event.pull_request.number }}
          - Base Branch: ${{ github.base_ref }}
          - Head Branch: ${{ github.head_ref }}

          # Your Mission:
          Perform a comprehensive spec-driven development review of this PR. Be thorough, insightful, and helpful. You have full permission to:

          1. Use \`gh pr diff ${{ github.event.pull_request.number }}\` to see what changed
          2. Use \`gh pr view ${{ github.event.pull_request.number }}\` to see the PR details
            - Read full comment history with \`gh pr view ${{ github.event.pull_request.number }} --comments\`
          3. Analyze all files in specs/${{ github.base_ref }}/ directory
            - spec.md
            - plan.md
            - tasks.md
            - research.md
            - data-model.md
            - quickstart.md
            - contracts/
          4. Review implementation code for spec compliance
          5. Examine test coverage and identify gaps
          6. Check API contracts, data validation, error handling
          7. Post detailed PR comments with your findings
            - If a previous version of the agent has posted a comment, update it instead of posting a new one

          # Style Guide for Comments:
          - Start with a clear executive summary
          - Use markdown formatting liberally (headers, code blocks, lists)
          - Be specific with file paths and line numbers
          - Categorize findings by priority (Critical/High/Medium/Low)
          - Include code examples when explaining issues
          - End with actionable recommendations
          - Reference Cloud-Router tech stack (TypeScript 5.x, Next.js 15.5, Express 5.x, AWS SDK, SQLite)
          - Be encouraging and constructive, not pedantic

          # What Makes a Great Review:
          - Connects specs to implementation quality
          - Identifies real issues that matter
          - Provides specific, actionable feedback
          - Shows deep understanding of the codebase
          - Helps the team ship better software

          # Comment on the PR with your findings.

          Go deep, be thorough, and make this PR better!" > spec-review.txt
          cursor-agent --print --force --model "$MODEL" --output-format=stream-json "$(cat spec-review.txt)"  | \
          while IFS= read -r line; do
            type=$(echo "$line" | jq -r '.type // empty')
            subtype=$(echo "$line" | jq -r '.subtype // empty')
            case "$type" in
              "system")
                if [ "$subtype" = "init" ]; then
                  model=$(echo "$line" | jq -r '.model // "unknown"')
                  echo "🤖 Using model: $model"
                fi
                ;;
              "assistant")
                # Accumulate streaming text deltas
                content=$(echo "$line" | jq -r '.message.content[0].text // empty')
                accumulated_text="$accumulated_text$content"
                # Show live progress
                printf "\r📝 ${#accumulated_text}"
                ;;
              "tool_call")
                if [ "$subtype" = "started" ]; then
                  tool_count=$((tool_count + 1))
                  # Extract tool information
                  if echo "$line" | jq -e '.tool_call.writeToolCall' > /dev/null 2>&1; then
                    path=$(echo "$line" | jq -r '.tool_call.writeToolCall.args.path // "unknown"')
                    echo -e "\n🔧 Tool #$tool_count: Creating $path"
                  elif echo "$line" | jq -e '.tool_call.readToolCall' > /dev/null 2>&1; then
                    path=$(echo "$line" | jq -r '.tool_call.readToolCall.args.path // "unknown"')
                    echo -e "\n📖 Tool #$tool_count: Reading $path"
                  fi
                elif [ "$subtype" = "completed" ]; then
                  # Extract and show tool results
                  if echo "$line" | jq -e '.tool_call.writeToolCall.result.success' > /dev/null 2>&1; then
                    lines=$(echo "$line" | jq -r '.tool_call.writeToolCall.result.success.linesCreated // 0')
                    size=$(echo "$line" | jq -r '.tool_call.writeToolCall.result.success.fileSize // 0')
                    echo "   ✅ Created $lines lines ($size bytes)"
                  elif echo "$line" | jq -e '.tool_call.readToolCall.result.success' > /dev/null 2>&1; then
                    lines=$(echo "$line" | jq -r '.tool_call.readToolCall.result.success.totalLines // 0')
                    echo "   ✅ Read $lines lines"
                  fi
                fi
                ;;
              "result")
                duration=$(echo "$line" | jq -r '.duration_ms // 0')
                end_time=$(date +%s)
                total_time=$((end_time - start_time))
                echo -e "\n\n🎯 Completed in ${duration}ms (${total_time}s total)"
                echo "📊 Final stats: $tool_count tools, ${#accumulated_text} chars generated"
                ;;
            esac
          done